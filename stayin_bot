import os
from flask import Flask, request
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler,
    ContextTypes, CallbackQueryHandler, filters
)
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import asyncio

# -------------------- CONFIG --------------------
TOKEN = os.environ.get("8437889078:AAEBcGd-lhd4ANKJ9pqsX1IpGOPMnx6YvFg")
GROUP_CHAT_ID = int(os.environ.get("GROUP_CHAT_ID", "-1001809106961"))
TIMEZONE = "Asia/Singapore"
PORT = int(os.environ.get("PORT", 10000))
RENDER_URL = os.environ.get("RENDER_URL")  # e.g. https://your-bot.onrender.com
# ------------------------------------------------

staying_tonight: list[str] = []

# -------------------- FLASK --------------------
app = Flask(__name__)

# -------------------- TELEGRAM BOT --------------------
telegram_app = Application.builder().token(TOKEN).build()

# /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.chat.type == "private":
        await update.message.reply_text(
            "Hi! üëã\n\n"
            "Send me your name to indicate you're staying in tonight.\n\n"
            "Example:\nJohn Tan\n\n"
            "üìã I will send the list to the group at 9:00 PM.\n"
            "üßπ The list resets automatically at 12:00 AM."
        )
    else:
        await update.message.reply_text("Please message me privately to indicate you're staying in.")

# Receive name
async def receive_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.chat.type != "private":
        return

    name = update.message.text.strip()
    if not name:
        await update.message.reply_text("Please send your name.")
        return

    name = name.title()
    if name not in staying_tonight:
        staying_tonight.append(name)
        await update.message.reply_text(f"‚úÖ Added: {name}\nI‚Äôll update the group at 9:00 PM.")
    else:
        await update.message.reply_text(f"‚ÑπÔ∏è {name} is already on the list.")

# /list
async def list_staying(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if staying_tonight:
        await update.message.reply_text("üè† Staying tonight:\n" + "\n".join(staying_tonight))
    else:
        await update.message.reply_text("No one is staying in yet.")

# /remove
async def remove_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not staying_tonight:
        await update.message.reply_text("The list is empty.")
        return

    keyboard = [[InlineKeyboardButton(name, callback_data=f"remove:{name}")] for name in staying_tonight]
    await update.message.reply_text("Select a name to remove:", reply_markup=InlineKeyboardMarkup(keyboard))

# Handle remove buttons
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data.startswith("remove:"):
        name = query.data.split(":", 1)[1]
        if name in staying_tonight:
            staying_tonight.remove(name)
            await query.edit_message_text(f"‚ùå Removed: {name}")
        else:
            await query.edit_message_text("Name not found.")

# -------------------- SCHEDULED JOBS --------------------
async def send_list_9pm():
    summary = "üìã Tonight's staying list:\n" + ("\n".join(staying_tonight) if staying_tonight else "No one is staying in.")
    await telegram_app.bot.send_message(chat_id=GROUP_CHAT_ID, text=summary)

async def clear_list_midnight():
    staying_tonight.clear()
    print("üßπ Staying list cleared at 12:00 AM")

# -------------------- TELEGRAM HANDLERS --------------------
telegram_app.add_handler(CommandHandler("start", start))
telegram_app.add_handler(CommandHandler("list", list_staying))
telegram_app.add_handler(CommandHandler("remove", remove_name))
telegram_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, receive_name))
telegram_app.add_handler(CallbackQueryHandler(button_handler))

# -------------------- FLASK ROUTES --------------------
@app.route("/", methods=["GET"])
def index():
    return "OK", 200

@app.route(f"/webhook/{TOKEN}", methods=["POST"])
async def webhook():
    update = Update.de_json(request.get_json(force=True), telegram_app.bot)
    await telegram_app.process_update(update)
    return "OK", 200

# -------------------- MAIN --------------------
async def main():
    # Scheduler
    scheduler = AsyncIOScheduler(timezone=TIMEZONE)
    scheduler.add_job(send_list_9pm, "cron", hour=21, minute=0)
    scheduler.add_job(clear_list_midnight, "cron", hour=0, minute=0)
    scheduler.start()

    # Start webhook
    webhook_url = f"{RENDER_URL}/webhook/{TOKEN}"
    print(f"Setting webhook URL: {webhook_url}")
    telegram_app.run_webhook(
        listen="0.0.0.0",
        port=PORT,
        webhook_url=webhook_url
    )

# -------------------- RUN --------------------
if __name__ == "__main__":
    asyncio.run(main())
